<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>resize</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      padding: 0;
    }

    .tooltip {
      width: 180px;
      height: 220px;
      font-size: 1em;
      line-height: 1.5;
      margin: 0;
      list-style: none;
      box-sizing: border-box;
      position: absolute;
      background: #fff;
      color: #333333;
      border-radius: 3px;
      /* transition: all .1s ease; */
      transform: translate(-50%, 0);
      box-shadow: 0 3px 8px 0 rgba(0, 0, 0, 0.1);
      /* padding: 10px 10px 8px; */
      text-align: center;
      opacity: 1;
      left: 368.88px;
      top: 16.646px;
      display: none;
    }

    .tooltip:after {
      content: '';
      display: block;
      width: 0;
      height: 0;
      position: absolute;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid #fff;
      left: calc(50% - 14px);
      bottom: -9px;
    }

    .removeButton {
      height: 25px;
      width: 25px;
      border-radius: 50%;
      display: inline-block;
    }

    .closeToolTipButton {
      /* color: red; */
      font-size: 1.3em;
      float: right;
      margin: 0;
      cursor: pointer;
    }

    .tabs {
      position: relative;
      /* min-height: 200px; */
      /* This part sucks */
      height: 55px;
      width: 180px;
      clear: both;
      margin: 0;
    }

    .tab {
      float: left;
    }

    .tab label {
      background: #eee;
      padding: 10px;
      border: 1px solid #ccc;
      margin-left: -1px;
      position: relative;
      left: 1px;
    }

    .tab [type="radio"] {
      display: none
    }

    .content {
      position: absolute;
      top: 28px;
      left: 0;
      background: white;
      right: 0;
      bottom: 0;
      /* padding: 20px; */
      border: 1px solid #ccc;
      border-left: none;
      border-right: none;
      border-bottom: none;
      overflow: hidden;
    }

    .content>* {
      opacity: 0;
      transform: translateX(-100%);
      transition: all 0.6s ease;
    }

    [type="radio"]:focus~label {
      outline: 2px solid blue;
    }

    [type="radio"]:checked~label {
      background: white;
      border-bottom: 1px solid white;
      z-index: 2;
    }

    [type="radio"]:checked~label~.content {
      z-index: 1;
    }

    [type="radio"]:checked~label~.content>* {
      opacity: 1;
      transform: translateX(0);
    }

    .content p {
      margin: 0;
    }

    .tooltip form {
      /* border: 1px solid #ccc; */
      border-top: none;
      border-left: none;
      border-right: none;

    }
  </style>
</head>

<body>

  <div class="tooltip" id="tooltip">
    <div class="tabs">
      <p class="closeToolTipButton">&#x2715</p>

      <div class="tab">
        <input type="radio" id="edit" name="tab-group" checked>
        <label for="edit">Edit</label>
        <div class="content">
          <p>Edit a segment</p>
        </div>
      </div>
      <div class="tab">
        <input type="radio" id="add" name="tab-group">
        <label for="add">Add</label>
        <div class="content">
          <p>Add a new segment</p>
        </div>
      </div>
    </div>
    <form>
      <label for="text">Text:</label><br>
      <input type="text" id="text" name="text" value=""><br>

      <label for="color">Color:</label><br>
      <input type="color" id="color" name="color" value="#ffff00">

      <input type="submit">
    </form>

    <button class="removeButton">-</button>
  </div>
  <div style="margin-top:300px;" id="bar-parent"></div>

  </div>

  <script>
    class BarMaker {
      constructor(initialState) {
        this.state = {
          bar: {
            height: 50,
          },
          segments: [],
          tooltip: {
            form: {
              state: "edit",
              element: null,
              colorInput: null,
              textInput: null,
              removeButton: null,
              closeToolTipButton: null
            },
            open: false,
            element: null
          },
          parentID: ""
        }
        this.selectedDivider = null
        this.leftWidth = 0
        this.rightWidth = 0
        this.bindHandlers = this.bindHandlers.bind(this)
        this.bindHandlers()
        this.initBar(initialState);
      }

      initBar(initialState = {}) {
        if (!initialState.segments || initialState.segements.length === 0) {
          initialState.segments = [
            {
              backgroundColor: "#ffff00",
              width: (1 / 3) * 100,
              height: `${this.state.bar.height}px`,
              innerText: "left",
              left: null,
              right: null,
              element: null
            },
            {
              backgroundColor: "#FFC0CB",
              width: (1 / 3) * 100,
              height: `${this.state.bar.height}px`,
              innerText: "middle",
              left: null,
              right: null,
              element: null
            },
            {
              backgroundColor: "#add8e6",
              width: (1 / 3) * 100,
              height: `${this.state.bar.height}px`,
              innerText: "right",
              left: null,
              right: null,
              element: null
            }
          ]
        }
        if (!initialState.parentID) {
          initialState.parentID = "bar-parent"
        }
        this.state = { ...this.state, ...initialState }

        this.parent = document.querySelector(`#${this.state.parentID}`)
        this.bar = document.createElement('div')
        this.bar.style.display = "flex"
        this.bar.style.height = `${this.state.bar.height}px`
        this.bar.style.position = "relative"
        this.drawBar()
        this.initToolTip()
        this.parent.appendChild(this.bar)
      }

      drawBar() {
        for (let i = 0; i < this.state.segments.length; i++) {
          const segmentDiv = document.createElement("div")
          const { backgroundColor, width, display, height, innerText } = this.state.segments[i]
          segmentDiv.style.backgroundColor = backgroundColor
          segmentDiv.style.width = `${width}%`
          segmentDiv.style.height = height
          segmentDiv.style.display = display
          segmentDiv.style.resize = "none"
          segmentDiv.innerText = innerText
          segmentDiv.setAttribute('draggable', 'true')
          segmentDiv.addEventListener('click', this.segmentClickHandler)
          segmentDiv.addEventListener('dragstart', this.segmentDragstartHandler)
          segmentDiv.addEventListener('dragenter', this.segmentDragentertHandler)
          segmentDiv.addEventListener('dragover', (e) => e.preventDefault())
          segmentDiv.addEventListener('dragleave', this.segmentDragleaveHandler)
          segmentDiv.addEventListener('dragend', this.segmentDragendHandler)
          segmentDiv.addEventListener('drop', this.segmentDropHandler)
          this.bar.appendChild(segmentDiv)
          this.state.segments[i].element = segmentDiv

          // If not the last segment, create divider, attach it as segment.right, make 
          // divider.left a reference to segment in state
          if (i !== this.state.segments.length - 1) {
            const dividerDiv = document.createElement('div')
            dividerDiv.style.backgroundColor = "black"
            dividerDiv.style.width = "0"
            dividerDiv.style.position = "relative"
            // The divider is a parent div with 0 width and relative pisition. It's
            // child is the actual visible divider with width 2px and position absolute
            // This allows us not to worry about divider width when calculating segment width
            const dividerChild = document.createElement('div')
            dividerChild.style.position = 'absolute'
            dividerChild.style.left = "-1px"
            dividerChild.style.width = "2px"
            dividerChild.style.backgroundColor = "black"
            dividerChild.style.height = `${this.state.bar.height}px`
            dividerDiv.appendChild(dividerChild)
            dividerChild.style.cursor = "ew-resize";
            dividerDiv.left = this.state.segments[i]
            this.state.segments[i].right = dividerDiv
            segmentDiv.insertAdjacentElement("afterend", dividerDiv)
            dividerChild.addEventListener("mousedown", this.dividerMousedownHandler)
          }

          // If not first segment, reference the right divider of last segment,
          // attach is segment.left, and reference current segment as divider.right
          if (i !== 0) {
            const dividerDiv = this.state.segments[i - 1].right
            this.state.segments[i].left = dividerDiv
            dividerDiv.right = this.state.segments[i]
          }
        }
      }

      // Removes the segments from the DOM, but does not affect state
      clearBar() {
        if (this.state.segments.length !== 0) {
          this.state.segments.forEach(seg => {
            seg.element.remove()
            seg.right && seg.right.remove()
          })
        }
      }

      // *************************** Tooltip Handlers *************************** \\

      initToolTip() {
        this.state.tooltip.element = document.querySelector('#tooltip')
        this.state.tooltip.form.element = document.querySelector('.tooltip form')
        this.state.tooltip.form.element.addEventListener('submit', this.tooltipFormSubmitHandler)
        this.state.tooltip.removeButton = document.querySelector('.removeButton')
        this.state.tooltip.removeButton.addEventListener('click', this.segmentRemoveHandler)
        this.state.tooltip.closeToolTipButton = document.querySelector('.closeToolTipButton')
        document.addEventListener('click', this.tooltipCloseHandler)

        document.querySelector(`input[type="radio"]#${this.state.tooltip.form.state}`).checked = true;
        document.querySelectorAll('input[name="tab-group"]').forEach((elem) => {
          elem.addEventListener("change", (e) => {
            const state = e.target.id;
            this.state.tooltip.form.state = state
          });
        });
        this.bar.appendChild(this.state.tooltip.element)
      }

      tooltipFormSubmitHandler(e) {
        e.preventDefault()
        const colorValue = this.state.tooltip.form.colorInput.value
        const textValue = this.state.tooltip.form.textInput.value
        if (this.state.tooltip.form.state === "edit") {
          this.selectedSeg.backgroundColor = colorValue
          this.selectedSeg.innerText = textValue
          this.clearBar()
          this.drawBar()
        } else if (this.state.tooltip.form.state === "add") {
          const index = this.state.segments.indexOf(this.selectedSeg)

          // We get the width of the new segment by getting how

          let leftLengths = 0
          for (let i = 0; i < index; i++) {
            leftLengths = leftLengths + this.state.segments[i].element.getBoundingClientRect().width
          }
          const pxFromLeft = this.x - this.bar.getBoundingClientRect().left - leftLengths
          const newWidth = (pxFromLeft / this.bar.getBoundingClientRect().width) * 100

          // const totalPercent = getTotalWidthPercent
          // const halfWidth = this.selectedSeg.width / 2
          this.selectedSeg.width = this.selectedSeg.width - newWidth
          const newSeg = {
            backgroundColor: colorValue,
            width: newWidth,
            display: "flex",
            height: "100px",
            innerText: textValue,
            left: null,
            right: null,
            element: null
          }

          this.clearBar()
          const segmentsCopy = [...this.state.segments]
          segmentsCopy.splice(index, 0, newSeg)
          this.state.segments = segmentsCopy
          this.drawBar()
        }
        this.selectedSeg = null
        this.x = 0
        this.state.tooltip.element.style.display = "none"
      }

      tooltipOpenHandler(e) {
        this.state.tooltip.element.style.display = "block"
        const location = { x: this.x - 4, y: this.bar.getBoundingClientRect().top }
        this.state.tooltip.element.style.left = `${location.x}px`
        this.state.tooltip.element.style.top = `-${this.state.tooltip.element.offsetHeight}`
      }

      tooltipCloseHandler(e) {
        console.log('close', e.target)
        if (this.state.tooltip.element.style.display !== "none") {
          if (!this.state.tooltip.element.contains(e.target)) {
            this.state.tooltip.element.style.display = "none"
          }
        }
        console.log('close after', this.state.tooltip)
      }

      // *************************** Segment Handlers *************************** \\

      segmentClickHandler(e) {
        console.log('open', this.state.tooltip)
        e.preventDefault()
        // Draw tooltip
        this.x = e.clientX

        // Set which segment we clicked on
        this.selectedSeg = this.state.segments.find(s => {
          return s.element === e.target
        })
        // Hydrate form
        this.state.tooltip.form.textInput = document.querySelector('input#text')
        this.state.tooltip.form.textInput.value = this.selectedSeg.innerText
        this.state.tooltip.form.colorInput = document.querySelector('input#color')
        this.state.tooltip.form.colorInput.value = this.selectedSeg.backgroundColor
        setTimeout(() => {
          this.tooltipOpenHandler()
        }
          , 0)
        console.log('open after', this.state.tooltip)

      }

      segmentRemoveHandler(e) {
        e.preventDefault()
        if (!this.selectedSeg.left && !this.selectedSeg.right) {
          console.log('You will have no more segments in your bar!')
        } else if (!this.selectedSeg.left) {
          this.clearBar()
          const neighbor = this.selectedSeg.right.right
          let totalWidthPercent = this.getTotalWidthPercent()
          const restWidthPercent = totalWidthPercent - parseFloat(this.selectedSeg.width)
          const newWidth = 100.00 - restWidthPercent + neighbor.width
          neighbor.width = newWidth
          neighbor.left = null
          this.state.segments = this.state.segments.filter(seg => seg.element !== this.selectedSeg.element)
          this.drawBar()
        } else if (!this.selectedSeg.right) {
          this.clearBar()
          const neighbor = this.selectedSeg.left.left
          let totalWidthPercent = this.getTotalWidthPercent()
          const restWidthPercent = totalWidthPercent - parseFloat(this.selectedSeg.width)
          const newWidth = 100.00 - restWidthPercent + neighbor.width
          neighbor.width = newWidth
          neighbor.right = null
          this.state.segments = this.state.segments.filter(seg => seg.element !== this.selectedSeg.element)
          this.drawBar()
        } else {
          this.clearBar()
          const leftNeighbor = this.selectedSeg.left.left
          const rightNeighbor = this.selectedSeg.right.right
          let totalWidthPercent = this.getTotalWidthPercent()
          const restWidthPercent = totalWidthPercent - parseFloat(this.selectedSeg.width)
          const halfWidth = (100.00 - restWidthPercent) / 2
          leftNeighbor.width = leftNeighbor.width + halfWidth
          rightNeighbor.width = rightNeighbor.width + halfWidth
          this.state.segments = this.state.segments.filter(seg => seg.element !== this.selectedSeg.element)
          this.drawBar()
        }
        this.state.tooltip.element.style.display = "none"
      }

      segmentDragstartHandler(e) {
        // create custome drag image
        const clone = e.target.cloneNode(true)
        clone.style.position = "absolute";
        clone.style.top = "-1000px";
        document.body.appendChild(clone);
        e.dataTransfer.setDragImage(clone, clone.getBoundingClientRect().width / 2, clone.getBoundingClientRect().height / 2)

        this.selectedSeg = this.selectedSeg = this.state.segments.find(s => {
          return s.element === e.target
        })
        console.log(this.selectedSeg)
      }

      segmentDragentertHandler(e) {
        e.preventDefault()
        this.draggedOver = this.state.segments.find(s => {
          return s.element === e.target
        })
        console.log('this.draggenter', this.draggedOver, this.selectedSeg)
        if (this.draggedOver.element !== this.selectedSeg.element) {
          this.draggedOver.element.style.borderBottom = 'black 3px solid'
        }
      }

      segmentDragleaveHandler(e) {
        e.target.style.border = 'none'
        e.preventDefault()
        if (e.target === this.draggedOver.element) {
          this.draggedOver = null
        }
        console.log('handleLeave', this.draggedOver, this.selectedSeg, e.target)
      }

      segmentDragendHandler(e) {
        console.log('this.draggedend', this.draggedOver, this.selectedSeg)
        // if(this.selectedSeg && this.selectedSeg.element === e.target){
        //   this.selectedSeg = null
        // }
        if (!this.draggedOver) {
          this.selectedSeg = null
          console.log('ended')
        }
      }

      segmentDropHandler(e) {
        e.preventDefault()
        console.log('handleDrop', this.draggedOver, this.selectedSeg)
        if (this.draggedOver && this.draggedOver.element !== this.selectedSeg.element) {
          console.log('dropped')
          const indexSelected = this.state.segments.indexOf(this.selectedSeg)
          const indexDraggedover = this.state.segments.indexOf(this.draggedOver)
          this.state.segments[indexSelected] = this.draggedOver
          this.state.segments[indexDraggedover] = this.selectedSeg
          this.clearBar()
          this.drawBar()
        }
        this.draggedOver = null
        this.selectedSeg = null
      }

      // *************************** Divider Handlers *************************** \\

      dividerMousedownHandler(e) {
        e.preventDefault()
        this.selectedDivider = e.target.parentNode;

        // Get the current mouse position
        this.x = e.clientX;
        this.leftWidth = this.selectedDivider.left.element.getBoundingClientRect().width;
        this.rightWidth = this.selectedDivider.right.element.getBoundingClientRect().width;

        // this.selectedDivider.style.cursor = "col-resize";
        document.body.style.cursor = "ew-resize";

        this.selectedDivider.left.element.style.userSelect = "none";
        // this.selectedDivider.left.element.style.pointerEvents = "none"; // removed onclickhanlder

        this.selectedDivider.right.element.style.userSelect = "none";

        // Attach the listeners to `document`
        document.addEventListener("mousemove", this.dividerMousemoveHandler);
        document.addEventListener("mouseup", this.dividerMouseupHandler);
      };

      dividerMousemoveHandler(e) {
        e.preventDefault()
        // How far the mouse has been moved
        const dx = e.clientX - this.x;
        const newLeftWidth =
          ((this.leftWidth + dx) * 100) /
          this.parent.getBoundingClientRect().width;
        this.selectedDivider.left.element.style.width = `${newLeftWidth}%`;
        this.selectedDivider.left.width = newLeftWidth

        const newRightWidth =
          ((this.rightWidth - dx) * 100) / // +2 because of width of dividers
          this.parent.getBoundingClientRect().width;
        this.selectedDivider.right.element.style.width = `${newRightWidth}%`;
        this.selectedDivider.right.width = newRightWidth
      }

      dividerMouseupHandler() {
        document.body.style.removeProperty("cursor");

        // this.selectedDivider.left.element.style.removeProperty("user-select");
        // this.selectedDivider.left.element.style.removeProperty("pointer-events");

        // this.selectedDivider.right.element.style.removeProperty("user-select");
        // this.selectedDivider.right.element.style.removeProperty("pointer-events");

        //old
        //  resizer.style.removeProperty("cursor");
        // document.body.style.removeProperty("cursor");

        // leftSide.style.removeProperty("user-select");
        // leftSide.style.removeProperty("pointer-events");

        // rightSide.style.removeProperty("user-select");
        // rightSide.style.removeProperty("pointer-events");

        // Remove the handlers of `mousemove` and `mouseup`


        this.leftWidth = 0
        this.rightWidth = 0
        this.x = 0
        this.selectedDivider = null

        document.removeEventListener("mousemove", this.dividerMousemoveHandler);
        document.removeEventListener("mouseup", this.dividerMouseupHandler);

        let totalWidthPercent = 0
        let totalWidthPixels = 0
        this.state.segments.forEach(seg => {
          totalWidthPixels += seg.element.getBoundingClientRect().width
          totalWidthPercent += parseFloat(seg.element.style.width)
        })
        console.log({
          totalWidthPercent,
          widthPixelsDiff: this.parent.getBoundingClientRect().width - totalWidthPixels
        })
      };

      // *************************** Utility Methods *************************** \\

      getTotalWidthPercent() {
        let totalWidthPercent = 0
        this.state.segments.forEach(seg => {
          totalWidthPercent += parseFloat(seg.element.style.width)
        })
        return totalWidthPercent
      }

      bindHandlers(){
        this.dividerMousedownHandler = this.dividerMousedownHandler.bind(this)
        this.dividerMousemoveHandler = this.dividerMousemoveHandler.bind(this)
        this.dividerMouseupHandler = this.dividerMouseupHandler.bind(this)
        this.tooltipFormSubmitHandler = this.tooltipFormSubmitHandler.bind(this)
        this.segmentClickHandler = this.segmentClickHandler.bind(this)
        this.segmentRemoveHandler = this.segmentRemoveHandler.bind(this)
        this.segmentDragstartHandler = this.segmentDragstartHandler.bind(this)
        this.segmentDragentertHandler = this.segmentDragentertHandler.bind(this)
        this.segmentDragleaveHandler = this.segmentDragleaveHandler.bind(this)
        this.segmentDragendHandler = this.segmentDragendHandler.bind(this)
        this.segmentDropHandler = this.segmentDropHandler.bind(this)
        this.tooltipCloseHandler = this.tooltipCloseHandler.bind(this)
        this.tooltipOpenHandler = this.tooltipOpenHandler.bind(this)
      }

      // createDivider(left = null, right = null) { return { left, right } };

      // createSegement(
      //   left = null,
      //   right = null,
      //   color = null,
      //   width = null
      // ) {
      //   return {
      //     left, right, color, width
      //   }
      // };
    }
    const bar = new BarMaker()

  </script>
</body>

</html>